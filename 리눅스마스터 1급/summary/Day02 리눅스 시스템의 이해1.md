# 2. 리눅스 시스템의 이해

## 2-1. 리눅스와 하드웨어

### 2-1-1. 하드웨어의 이해

1. 하드웨어의 이해
   1. 컴퓨터의 구성 요소
      1. 중앙처리장치
         - 외부에서 정보를 입력 받아 명령어 해석, 연산, 결과 반환, 컴퓨터 제어장치
         - CPU는 레지스터(Register)와 연상장치(ALU: Arithmetic-Logic Unit), 제어장치(Control Unit)
           - 레지스터: CPU가 연산을 처리하기 위한 임시 저장소 역할, 작은 데이터만을 저장할 수 있음, 액세스 속도가 빠르다
           - 연산장치: 데이터들 간 비교, 판단, 연산 수행
           - 제어장치: 명령어 해석, 해석한 명령을 연산장치 등으로 보내고 주소를 디코드하여 레지스터에 데이터를 저장
      2. 주기억장치
         - CPU가 처리할 명령어와 데이터를 저장하기 위한 컴퓨터 하드웨어 장치
         - RAM(Random Access Memory): 휘발성 메모리
           - 전원 공급 중단시 손실, 어느 주소 접근하든지 엑세스 시간 동일
           - DRAM(Dynamic Random Access Memory), SRAM(Static Random Access Memory)로 나뉨
         - ROM(Read Only Memory): 비 휘발성 메모리
           - 전원 공급 중단되도 손실x, 컴퓨터를 처음 킬 때 구동하기 위한 BIOS같은 프로그램 적재
           - MASK ROM: 저장 데이터를 변경x, PROM(Programmable ROM): 1회 수정 가능, EPROM(Erasable PROM): 수정 가능한 ROM
      3. 입출력장치
         - 입력장치: 키모드, 마우스, 카메라, 스캐너, 터치스크린, 바코드 등
         - 출력장치: 모니터, 프린트
      4. 보조기억장치
         - 보조기억장치는 속도는 느리나 요량이 크고 저렴
         - 데이터 저장, 메모리 부족시 스왑 영역, 운영체제가 저장되어 있음
         - 하드디스크, SSD(Solid State Drive), CD-ROM, DVD, BD(Blu-ray Disc) 등

2. 리눅스 설치를 위한 하드웨어 요구사항
   1. CPU
      - 리눅스는 CPU에서 제공하는 어셈블리 언어와 쉽게 이식 가능한 C언어로 개발이 진행
      - 따라서 CPU 종속 특성 부분만 어셈블리 언어로 구현, 나머지는 C로 구성
      - GNU C가 지원하는 CPU 환경이면 이론적으로 리눅스 구동 가능
      - 인텔 x86, x64, x86_64, AMD 계열은 구동 가능
      - SPARC, Alpha, PowerPC, ARM, MIPS 등 지원
      - 병렬성(parallelism)을 높여 CPU의 최대 성능을 높이기 위해 CPU의 코어의 개수를 고려
   2. 메인보드
      - 거의 대부분 메인보드 지원
   3. 메모리
      - 거의 모든 메모리 지원
      - 32bit CPU에서 4G 이상 메모리를 필요한 경우 PAE(Physical Address Extendsion) 기술 사용 극복
      - 64bit CPU에서는 CentOS 6 기준 64TB까지도 사용 가능
   4. 하드디스크
      - IDE, E-IDE, SCSI, S-ATA 등 대부분 인터페이스를 지원
      - 파티션 설정 및 스왑 설정 가능
      - 장치를 파일로 관리하는 특징, IDE or ATA 인터페이스 경우 /dev/hdX 파일과 매핑
      - S-ATA, USB, SSD< SCSI는 /dev/sdX 파일과 매핑
   5. 모니터와 그래픽 카드
      - 대부분 모니터와 그래픽 카드 지원
      - 시스템에 장착된 그래픽 카드 알아보는 명령어: `lspci | grep -I vga`
   6. LAN 카드
      - 대부분 LAN 카드 기본으로 제공, 다양한 규격을 지원, 무선랜 지원
      - 네트워크 설정이 안될 시 제조사의 웹사이트 방문하여 드라이브 제공 여부 확인
      - 네트워크 설정을 위해 IP주소, 넷마스크, 게이트웨이 주소, DNS 서버 주소 등을 기관 네트워크 관리자를 통해 확인
   7. 키보드 및 마우스
      - 대부분 키보드와 마우스 지원, PS/2, Serial, USB 지원

### 2-1-2. 하드웨어의 선택

1. RAID의 개요
   1. 하드의 고성능 구현과 신뢰성을 여러 개의 하드디스크를 구성하고 중복된 데이터를 나눠서 저장
   2. 복수 배열 독립 디스크(Redundant Array of Independent Disks)기술
   3. RAID 0은 고성능 구현, RAID 1은 무정지 구현, RAID 1+0은 혼합한 형태
   4. RAID 5, RAID 6은 고성능과 무정지 추구
   5. 하나의 RAID 운영체제에서 논리적으로 하나의 하드디스크로 인식
   6. 스트라이핑 기술은 디스크 성능 향상, 라운드 로빈 방식으로 기록하는 기술
   7. 미러링 기술은 무정지를 위한 핵심 기술, 에러 발생 시 보호

2. RAID의 종류
   1. RAID-0
      - 데이터를 여러 디스크에 걸쳐 저장(스트라이핑 기술) 적용, 분산 저장
      - 저장시 동시에 여러 디스크에 쓰기 가능, 처리속도가 빠름
      - 디스크 오류시 복구 불가
   2. RAID-1
      - 패리티나 스트라이핑 없이 미러링 기술 사용, 데이터 두 개의 디스크에 동시 기록
      - 동시에 읽어들여 읽기 속도 향상, 쓰기 향상x, 효율성50%, 디스크 오류시 데이터 복구 가능
   3. RAID-2
      - bit 레벨의 스트라이핑 기술 적용, 최소 3개의 디스크에 분산 저장
      - 오류 정정 부호(ECC)를 기록하는 전용 하드디스크 이용
      - 오류 복구가 가능하지만 연산이 필요해 입출력 속도 저하
   4. RAID-3
      - byte 수준의 스트라이핑을 통해 데이터 분산 저장
      - 읽거나 쓸 때 각 디스크 동시 접근 가능, 순차 쓰기, 순차적 읽기 우수
      - 패리티 제공, 오류 체크 및 복구 가능
   5. RAID-4
      - block 레벨의 스트라이핑 제공, 데이터 분산 저장, 패리티 이용
      - 블록단위로 데이터 저장되 단일 디스크에서 데이터를 읽어 들일 수 있고 여러 디스크에서 동시에 읽기 가능
      - 데이터를 쓸 때 마다 패리티 디스크 접근, 쓰기 성능 저하
   6. RAID-5
      - RAID-4 와 같이 블록 수준 스트라이핑 저장, 패리티도 모든 디스크에 나눠 저장
      - 성능이 RAID0 보다 부족하지만 성능, 안정성, 요량 모두 우수
      - 현장에서 많이 사용
   7. RAID-6
      - RAID-5와 유사한 구성, 2차 패리티 구성 포함
      - 2개의 디스크 오류에 대처 가능
   8. RAID 0 + 1
      - 디스크 2개를 스트라이핑 후 미러링 적용
   9. RAID 1 + 0
      - 미러링 적용 후 스트라이핑, RAID 1보다 높은 성능 but 비쌈
   10. RAID 5 + 3
       - RAID-3 방식에 스트라이프 어레이 구성, 높은 성능 but 비쌈

3. 디스크 인터페이스
   1. IDE
      - 가장 오래된 규격, 40핀 병렬 인터페이스
      - PATA(Parallel Advanced Technology Attachment) 라고도 불림, 병렬 전송 강조
      - IDE 보다 성능이 향상 E-IDE(Enhanced IDE)가 있으며 133.3MB/s 속도로 전송
   2. S-ATA
      - IDE 성능 한계 극복, 직렬로 데이터 전단
      - SATA1 150MB/s, SATA2 300MB/s, SATA3 5Gb/s
      - SATA2는 허브를 이용해 하나의 포트에 여러 개 하드디스크 연결 가능
   3. SCSI(Small Computer System Interface)
      - 고성능, 안정성, 신뢰성 중시하는 워크스테이션 및 서버에 주로 사용
      - 10000RPM 고성능 하드 장착 최적 성능, 병령 방식 성능의 한계
   4. SAS(Serial Attached SCSI)
      - SCSI 한계 극복, 시리얼 방식 디스크 인터페이스
      - SCSI의 안성정, 확장성, 신뢰성을 이어함, 시리얼 전송을 통해 속도 향상

4. LVM(Logical Volume Manger)
   1. LVM 개요
      - 블록 디바이스를 유연하게 관리하기 위해 여러 블록디바이스를 가상의 Logical Volume에 매핑, 스토리지를 관리하는 커널 기능
      - 기존 블록디바이스에 직접 I/O를 수행, LVM은 LVM이 매핑한 Logical Volume에 I/O를 수행
      - 유연한 용량, 크기 조절 가능한 스토리지 풀, 온라인 데이터 재배치, 디스크 스트라이핑, 미러 볼륨, 볼륨 스냅샷
   2. LVM 구성도
      1. Volum Group(VG01)
         1. Physical Volume(/dev/sda3): 일부를 Logical Volume(/var)에 매치, 남은걸 Logical Volume(/home)에 매치
         2. Pyshical Volume(/dev/sdb2): 일부를 Logical Volume(/home)에 매치, 남은걸 남겨둠
         3. Logical Volume(/var)
         4. Logical Volume(/home)
   3. LVM 구성요소
      1. PV(Physical Volume): 기존 블록 디스크를 LVM에서 사용할 수 있도록 변환한 볼륨 형식
      2. PE(Physical Extent): PE라 불리는 일정 크기의 블록들이 모여 PV, 기본 크기는 4MB
      3. VG(Volume Group): 여러 PV를 묶어 VG로 토합 가능, VG에 LV 할당 가능
      4. LV(Logical Volume): VG에서 필요한 만큼 할당하여 만들어지는 공간, 사용자는 LV통해 하드에 접근
      5. LE(Logical Extent): LV를 구성하는 일정 크기의 블록, 기본 키그는 4MB

## 2-2. 리눅스의 구조

### 2-2-1. 부트 매니저

1. 부트 매니저의 개요
   1. 정의
      - 부트 매니저(Boot Manger)는 보조기억장치에 위치한 운영체제를 주기억장치로 로드하기 위한 프로그램
      - 부트 로더(Boot Roader) 라고도 함
   2. 동작원리
      - 시스템이 켜지면 BIIOS는 디스크의 첫 번째 섹터(0번 섹터)인 부트 섹터에서 512바이트 MBR(Master Boot Record)를 읽음
      - IPL은 파티션 테이블을 검사, 부트 로더의 나머지 코드의 위치를 알아내 실행
      - 리눅스의 대표적인 부트 매니저 프로그램은 LILO(Linux Loader)와 GRUB(Grand Unified BootLoader)

2. 부트 매니저 종류
   1. LILO(Linux Loader)
      - 모든 리눅스 배포판의 표준, 가장 오래된 부트 로더, 지속적인 커뮤니티의 지원
      - 1,024개의 실린더 인식 한계가 있던 부분도 개선
      - LILO 설정: `/etc/lilo.conf`
      - 설정 파일 변경 후 LILO stage 1 부트 로더를 MBR로 다시 쓰기 위해 `lilo` 명령을 반드시 수행
   2. GRUB(Grand Unified Boot Loader)
      - GUN 프로젝트에서 만든 부트 로더
      - LILO와 달리 대화형 명령어 인터페이스를 제공, 네트워크 부팅 제공
      - 배포판마다 설정 파일명이 다를 수 있지만 CentOS 6의 경우 `/boot/grub/grub.conf` 파일 존재
      - GRUB은 설정 파일 변경 후 특별한 조치 없이 적용

3. GRUB 사용해보기
   1. GRUB 초기화면
      - 부팅 시 아무키나 누르면 화면 진입
      - GRUB로 부팅할 수 있는 운영체제 목록 확인 가능
      - `e`: 해당 목록의 부트 로더 설정 변경
      - `a`: 부트 로더 설정 중 커널에 인자를 수정
      - `c`: 명령 줄 모드로 진입
   2. GRUB 편집화면
      - `e`: 편집화면 진입
      - /boot/grub/grub.conf에 설정된 root, kernel, initrd 설정을 임시로 변경 가능

4. GRUB 환경설정 파일
   1. boot: 부팅 디스크 설정, 디스크가 하나일 시 주석 표시
   2. default: 아무 선택 하지 않을 시 부팅할 운영체제의 순서
   3. timeout: 최대 시간, 시간 만료시 default 설정된 운영체제 로드
   4. splashimage: GRUB 화면의 배경 이미지
   5. title: GRUB 부딩 메뉴 표시되는 이름
   6. root: 루트 디바이스 설정, x는 하드디스크 파일명, y는 부트 파이션 번호
   7. kernel: 부딩에 사용할 커널 이미지 파일 경로 지정, 매개변수 설정, root 파티션 위치 설정
   8. rootnoverify: root와 유사, 해당 파티션 마운트x, NTFS 파이션과 같이 GUB이 인식할 수 없는 파티션을 root 디바이스로 지정할 때 사용

### 2-2-2. 주요 디렉터리 구조

1. 리눅스 파일시스템 표준(FHS: File system Hierarchy Standard)
   1. 파일시스템 표준은 BSD 파일시스템 계층 구조 기반, 디렉터리 구조 표준
   2. 리눅스 재단(HP, 레드햇, IBM, Dell 등)이 관리, 최신 버전 2.3(2004.01.29)

2. 리눅스의 주요 디렉터리
   1. `/`: 리눅스 파일시스템의 최상위 디렉터리
   2. `/bin/`: 모든 사용자가 사용할 수 있는 명령어(ls, cp, mkdir 등)
   3. `/boot/`: 커널 파일, initrd 등 부팅이 필요한 파일(grub 파일 등)
   4. `/dev/`: 디바이스 파일(하드, CPU, 네트워크 등)
   5. `/etc/`: 시스템 환경 설정 파일, 시스템초기화시 수행되는 여러 스크립트 파일(Editable Text Configuration, Extended Tool Chest)
   6. `/home/`: 로그인한 사용자 전용 홈 디렉터리
   7. `/lib/`: 시스템에 설치된 각종 라이브러리가저장된 디렉터리, `/lib/modules`에는 설치된 커널 모듈이 위치
   8. `/media/`: CD-ROM or USB 등 마운트 시 이 디렉터리를 사용
   9. `/mnt/`: 다양한 디바이스가 마운트 시 사용하는 임시 디렉터리
   10. `/opt/`: 추가 어플리케이션 소프트웨어 패키지
   11. `/proc/`: 프로세스들이 파일 형태로 매핑, 가상 파일시스템으로 구현, 프로세스, 하드웨어, 기타 시스템 정보를 확인 가능
   12. `/root/`: 루트 사용자 홈 디렉터리
   13. `/sbin/`: system binary의 약자, shutdown, ifconfig, 시스템 점검과 복구, root가 사용하는 시스템 관리 명령어 등이 포함
   14. `/tmp/`: 임시 파일 생성 디렉터리, /var/tmp와 같은 공용 디렉터리로 퍼미션 1777, sticky bit 설정되어 있음
   15. `/usr/`: 사용자들이 사용하기 위해 설치한 주요 명령어들
   16. `/usr/bin/`: 대부분의 사용자 명령어를 포함, Perl 같은 명령어
   17. `/usr/include/`: C, C++ 등 프로그램 언어가 사용하는 헤더 파일이 위치
   18. `/usr/lib/`: /usr/bin 과 /usr/sbin에 있는 바이너리에 링크하기 위한 라이브러리
   19. `/usr/sbin/`: 시스템 관리자가 사용하는 명령, 중요하지 않은 명령어들이 위치
   20. `/usr/src/`: 다양한 바이너리 소스코드 위치, 리눅스 커널의 소스코드도 여기에 위치
   21. `/usr/X11R6/`: X 윈도우 시스템 관련 파일 위치
   22. `/var/`: 로그, 스풀 파일 등 임시 생성, 상황에 따라 생성되거나 삭제될 수 있는 데이터 보관

### 2-2-3. 부팅과 셧다운

1. 부팅의 개요
   1. 부팅: 컴퓨터가 켜지고 사용자가 시스템을 사용할 수 있도록 운영체제를 기동하는 절차
   2. 부팅 위해 BIOS, MBR 부트 로더 실행, 부트 로더는 지정 위치의 커널을 메모리에 읽어 드린 후 프로세스 실행
   3. 사용자 지정 실행 레벨에 따라 지정된 스크립트 수행, 운영체제의 나머지 초기화

2. 부팅의 상세 절차
   1. 단계: 시스템 시작 및 하드웨어 초기화 -> 부트 로더 1단계 -> 부트 로더 2단계 -> 커널 -> INT 프로세스 -> 사용자 프롬프트
   2. 시스템 시작 및 하드웨어 초기화
      - 가장 먼저 ROM 영역의 저장된 프로그램을 실행
      - POST(Power On Self Test) 기능 실행: 그래픽 카드 체크, 메인보드, 주변 장치 체크, 과정 모니터에 출력
   3. 부트 로더 1단계
      - MBR: 하드디스크의 0번 섹터, 운영체제 로드를 위한 부트 로더가 위치
      - 0번 섹터: 512byte로 크기가 한정, 실제 부트 로더가 위치한 디스크로 점프하는 역할까지 수행
   4. 부트 로더 2단계
      - 부트로더 실행, LILO, GRUB 등
      - GRUB은 MBR 이후 약 30kilobytes 내에 연속된 주소에 위치, `grub.conf` 설정에 따라 선택할 운영체제 목록을 표시
      - 사용자가 운영체제를 선택 시 커널을 메모리에 로드, 커널에게 제어권 전달
   5. 커널
      - 하드, 소프트웨어 관장하는 핵심 모듈
      - 한번 메모리(RAM)에 로드되면 시스템 리부트, 종료할 때까지 상주
      - GRUB으로부터 제어권을 이어받은 커널은 INIT 프로세스를 실행
   6. INT 프로세스
      - INIT 프로세스: 초기화 작업을 다음 단계로 수행
      - `/etc/rc.d/rc.sysinit` 스크립트 실행
      - 위 스크립트에서는 시스템의 프로퍼티, 하드웨어, 디스플레이, SELinux, 커널, 모듈, 파일시스템 마운트 등을 체크
      - `/etc/inittab` 파일을 읽어 실행레벨 확인, 그에 맞는 스크립트 실행
      - 예를 들어 실행레벨이 5인 경우 `/etc/rc5.d` 디렉터리에 위치한 스크립트 실행
      - 실행레벨 관련 스크립트 수행 후, `etc/rc.local`에 정의된 프로세스를 실행
      - 0: 시스템 종료
      - 1: 단일 사용자 모드(시스템 복원모드, Root 권한을 셸로 얻음)
      - 2: 다중 사용자 모드(네트워크 제공x)
      - 3: 다중 사용자 모드(네트워크 제공o)
      - 4: 현재 사용되고 있지 않은 모드
      - 5: X 윈도우 사용하는 다중 사용자 모드
      - 6: 시스템 재부팅시 사용하는 실행레벨
   7. 사용자 프롬프트(user prompt)
      - 모든 초기화 완료시 실행레벨에 따라 다르지만 X-Window나 terminal을 통해 입력을 받을 준비 완료

3. 로그인과 로그아웃
   1. 로그인
      - multi user를 지원하기 때문에 아이디 패스워드로 사용자 식별, 실행환경을 독릭접으로 제공
      - INIT 프로세스의 실행레벨에 따라 단일 유저, 멀티 유저, X윈도우를 통한 멀티 유저 모드로 나뉨
        - 1(single user), 2, 3(multi user): 네트워크 비제공, 제공, 5(X-window): 그래픽으로 로그인 가능
   2. 로그아웃
      - 로그아웃을 하지 않으면 악의적 사용자에게 시스템이 노출될 가능성, `Ctrl` + `D` 로 로그아웃 가능
      - 자동 로그아웃 설정 -> `vi /etc/profile` -> `TMOUT=10` 설정(10초로 설정)

4. 로그인/로그아웃 관련 문제 해결
   1. Root 패스워드 분실 대응하기
      - GRUB 부트 메뉴 진입 -> `a` -> 마지막에 `single` 을 치고 `Enter` -> `passwd`로 비밀번호 변경
      - CentOS의 자세한 내용은 링크 참고 -> [응급 복구](https://github.com/wansang93/OS/blob/master/%EC%9D%B4%EA%B2%83%EC%9D%B4%20%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8B%A4/summary/Chapter04-14.md#%EC%9D%91%EA%B8%89-%EB%B3%B5%EA%B5%AC)
   2. GRUB 패스워드 분실 대응하기
      - 설치된 디스크를 통해 부팅 -> `Rescue install system` 선택 -> 복구 모드 진입 네트워크 No, 마운트 Continue
      - 셸에서 `/mnt/sysimage/boot/grub.grub.conf`를 편집해 `password` 변수를 삭제, GRUB 패스워드를 제거

5. 시스템 종료
   1. X 윈도우 환경에서 셧다운하기
   2. 시스템 종료 방법
      - `shutdown -h now`, `halt`, `poweroff`, `init 0`
   3. 시스테을 재부팅하는 방법
      - `shutdown -r now`, `reboot`, `init 6`
   4. 예약된 시간에 시스템을 종료하거나 재시작(reboot)하는 방법
      - `shutdown -h +5`, `shutdown -r 10:00`

### 2-2-4. 파일시스템의 이해

1. 파일시스템의 개요
   1. 디스크에 사용자가 효율적으로 저장, 디렉터리와 파일을 조직화
   2. 디스크 포맷 작업 -> A4 종이에 줄을 긋기와 비슷, 일정 크기로 분할, 주소를 설정, 조직적 보관 가능
   3. 유저의 데이터는 파일 단위로 관리, 디스크 저장 시 레코드 or 블록 단위로 저장, 각 파일은 디렉터리에 속해있음
   4. 입출력 시 발생하는 오류에 대해 복구 기능 제공
   5. 입출력 시 속도가 느려 파일시스템은 캐시 기능 제공, 디스크의 입출력 최소화

2. 리눅스파일시스템의 구조
   1. ext2 개요
      - ext3, 4는 2를 근간으로 발전
   2. 부트 섹터(boot sector)와 블록 그룹(block group)
      - ext2 파일시스템은 부트 섹터와 그에 뒤따르는 여러 개의 블록 그룹들로 구성
      - 블록 그룹은 모두 같은 블록 개수를 가짐, 마지막 블록 그룹은 예외
   3. 블록 그룹
      - 여러 개의 블록으로 구성
      - 스케줄링: 한 파일이 여러 블록에 나눠서 저장되어야 하는 경우 단편화를 최소화를 위해 동일 블록 그룹에 위치하게 함
      - 슈퍼 블록과 그룹 디스크립터 테이블은 0번 블록 그룹에만 포함되어도 기능 상 문제는 없으나, 손상 시 파일시스템 접근이 불가능해 다른 블록 그룹에도 사본이 보관
      - 블록 비트맵은 그룹 내의 각 블록이 할당되어 있는 여부를 비트로 표현, 4KB 크기의 블록이면 32768개의 블록 할당 여부 표현 가능
      ![블록 그룹](../assets/Day02%20블록그룹.png)
   4. 슈퍼 블록(super block)
      - 파일시스템의 전체 내용을 담고 있는 블록으로 1KB만 사용, 4KB 블록 사용시 3KB는 비워둠
      - 구성: 블록의 크기, 블록의 총 갯수, 블록 그룹의 갯수, 아이노드의 갯수, 그룹 내 블록의 갯수, 그룹 내 아이노드의 갯수 등
   5. 그룹 디스크립터 테이블(group descriptor table)
      - 블록 그룹에 대한 정보, 32byte 크기인 그룹 디스크립터의 목록
      - 구성: 블록 비트맵의 블록번호, 아이노드 비트맵의 블록번호, 첫 번째 노드 테이블의 블록 번호, 그룹 안에 있는 빈 블록 수, 그룹 안에 있는 아이노드 수, 그룹 안에 있는 빈 디렉터리 수
   6. 블록 비트맵(block bitmap)
      - 블록 할당 여부를 비트로 표현
   7. 아이노드 비트맵(i-node bitmap)
      - 아이노드 할당 여부를 비트로 표현
   8. 아이노드 테이블(i-node table)
      - 연속된 블록으로 구성, 각 블록은 미리 정의된 아이노드 개수를 포함
      - 첫 번째 블록의 번호를 그룹 디스크립터 테이블에 저장
      - 모든 아이노드의 크기는 128바이트로 동일
   9. 아이노드(i-node)
      - 아이노드는 실제 파일과 디렉터리의 데이터 위치를 알고 있는 자료구조
      - 구성: Inode Number, 파일모드, 하드링크 수, 소유자 ID, 파일 크기, 마지막 접근, 마지막 수정, Inode 수정, 데이터 블록 수의 정보
      - 모든 파일과 디렉터리는 각 1개의 아이노드를 가지고 고유한 주소를 가지고 있음
      - 아이노드 주소를 알면 해당 아이노드가 가리키는 블록 그룹을 찾아갈 수 있음
      - 아이노드 1번부터 10번까지 예약이 되어 있음(1번: 슈퍼 블록, 2번 루트 디렉터리)
   10. 디렉토리/데이터 블록
       - ext2 내부는 15개의 포인터가 있는 구조(1~12번: 직접 블록, 13번: 간접 블록, 14번: 이중 간접 블록, 15번: 삼중 간접 블록)

3. 리눅스 로컬 파일시스템(Local Filesystems)
   1. ext
      - minix 파일 시스템 개선, 레미카트(Remy Card)는 최대 2Gb 파티션, 255까지 파일명 지원
      - 파일 접근에 대한 타임스탬프, 아이노드 수정기능 부재와 조각화 이슈
   2. ext2
      - ext 한계 극복, 타임스탬프, 아이노드 수정, 조각화 이슈 해결
      - 데이터를 쓰는 동안 전원이 끊길 시 저장 문제, fsck 명령어 사용하여 복구, 시간이 오래걸림
      - 파일시스템의 크기: 블록 단위에 따라 2TiB~32TiB
      - 파일 크기: 블록 단위에 따라 16GiB~64TiB
   3. ext3
      - 리눅스 커널 2.4.15 버전부터 포함, 저널링 파일시스템
      - 전원이 끊길 시 복구 기능 제공, 로그를 통해 파일시스템 복구, 저널링 기술 채용
      - 저널링: 저널 모드(journal mode), 순서 모드(ordered mode), 쓰기 저장(writeback mode)
      - 온라인 파일시스템 증대, 큰 디렉터리를 위한 HTree 인덱싱 기능, ACL을 통한 접근 제어 제공
      - 온라인 조각모음 프로그램이 없음
   4. ext4
      - ext2, ext3 호환, 64비트 기억 공각 제약 해결, 디스크 볼륨: 1Exabyte, 파일: 16Terabyte 지원
      - 큰 파일 처리 개선, 단편화 현상 줄이기 위해 extends 방식 사용(기존은 block mapping 방식)
      - ext2, ext3를 ext4 방식으로 마운트, 성능 향상된 상태로 사용 가능
      - ext4는 ext3 방식으로 마운트 가능, Extents를 사용하는 ext4 파티션은 ext3 방식으로 마운트 불가
      - 파일시스템 손상 가능성을 줄여주는 저널 체크섬 기능 제공
      - 32,000 서브 디렉토리 -> 64,000 늘림
      - 온라인 조각모음 기능 제공, 나노초단위 파일스탬프 제공
   5. btrFS
      - B-Tree 파일시스템
      - 특정 파일, 볼륨, 하위 볼륨의 스냅샷 찍기 기능 제공
      - 저렴한 디스크의 RAID 제공
      - 역참조는 파일시스템 개체에 I/O 오류를 매핑
      - 자동 압축 기능 제공
      - 데이터 및 메타 데이터의 체크섬을 제공
   6. ZFS
      - 유닉스의 파일 시스템을 대체하기 위해 개발
      - 볼륨 매니저 역할도 수행
      - 볼륨 관리 기능, 블록 수준 암호화, 데이터 손상 탐지, 자동 손상복구, 신속한 비동기 증분 복제, 인라인 압축 등
   7. Reiserfs
      - 커널 2.4.1 포함, 저널링 파일시스템
   8. XFS
      - 커널 2.4.20 포함, 고성능 64비트 저널링 파일시스템
   9. JFS
      - 커널 2.4.24 포함, 64bit 저널링 파일시스템

4. 클러스터 파일시스템(Clustered Filesystems)
   1. RAW Partitions
      - 파일시스템이 설정되어 있지 않은 상태
      - 버퍼캐시를 사용x, 고성능의 입출력 가능
      - 오버헤드가 없음
      - 숙련된 관리자가 필요
   2. Oracle Cluster FilesSystem(OCFS)
      - RAC(Real Application Cluster)의 사용 목적을 위해 설계된 파일시스템
      - RAW Partition보다 2~5% 속도가 느려 효율이 좋은 편에 속함
      - OCFS의 다음버전인 OCFS2는 POSIX를 호환하는 범용 클러스터 파일시스템으로 개발

5. 기타 리눅스 파일시스템
   1. minix
      - 교육 목적으로 minix 운영체제 개발, minix 파일시스템이 포함
      - 토발즈도 초기 리눅스 개발 시 MINIX를 파일시스템으로 채용
      - 파티션 사이즈가 64MB, 이름 14자로 지원, 단일 타임스탬프 사용
   2. xiafs
      - Minix 파일시스템의 기초가 됨, 리눅스 커널을 위한 파일 시스템
   3. vfat
      - 마이크로소프트 FAT32 파일시스템 호환을 목적으로 개발한 파일 시스템
   4. isofs
      - ISO 기준을 따르는 표준 CD-ROM 파일시스템
   5. nfs
      - 네트워크상에서 파일시스템을 공유하기 위한 파일시스템
   6. proc
      - 프로세스 등 커널의 정보를 표현하는 리눅스의 가상 파일시스템
   7. smb
      - SMB 프로토콜을 지원하는 네트워크 파일시스템, 최근 CIFS로 확장
